# CEGS GNN 优化：集成边角色信息\n\n本项目旨在增强 CEGS (Configuration Example Generalizing Synthesizer) 框架中的图神经网络 (GNN) 组件，特别是 Querier (查询器) 和 Classifier (分类器)。核心目标是通过将"边角色信息"（描述网络连接类型或功能的类别化特征）显式地整合到 GNN 的消息传递机制中，来提升 CEGS 在配置示例推荐和节点映射方面的性能。\n\n我们实现了三种 GNN 策略：\n1.  **Baseline GraphSAGE**: 作为基准模型，不直接使用边特征。\n2.  **R-GCN (Relational Graph Convolutional Network)**: 一种为图中的不同关系类型（即边角色）学习专属参数的 GNN。\n3.  **Edge-Conditional GraphSAGE**: 一种改进的 GraphSAGE，其消息计算过程同时依赖于邻居节点特征和连接边的特征。\n\n## 项目结构\n\n```\n.\n├── cegs_gnn/                   # 主要的 GNN 相关代码包\n│   ├── data_utils/             # 数据加载和处理工具\n│   │   ├── data_loader.py      # 数据集类、边角色编码器、合成数据生成器\n│   │   └── graph_utils.py      # 图操作和可视化辅助函数\n│   ├── evaluation/             # 模型评估相关代码\n│   │   ├── evaluator.py        # 模型评估器类，执行评估任务\n│   │   └── metrics.py          # 常用的评估指标实现\n│   ├── examples/               # 示例脚本和 Jupyter Notebook\n│   │   ├── notebooks/\n│   │   │   └── edge_role_gnn_example.ipynb # Notebook 演示\n│   │   ├── simple_train.py     # 简化的训练和评估脚本\n│   │   └── train_and_evaluate.py # 主要的训练和评估脚本\n│   ├── models/                 # GNN 模型定义\n│   │   ├── baseline.py         # 基准 GraphSAGE 模型\n│   │   ├── edge_sage.py        # 边条件 GraphSAGE 模型\n│   │   └── rgcn.py             # R-GCN 模型\n│   ├── training/               # 模型训练相关代码\n│   │   └── trainer.py          # 模型训练器类\n│   ├── __init__.py\n│   ├── README.md               # (包内旧的 README)\n│   ├── requirements.txt        # Python 依赖\n│   └── test_models.py          # 简单的模型实例化和前向传播测试\n├── data/                       # 存储处理后的数据集缓存 (由 .gitignore 忽略)\n├── results/                    # 存储训练结果和图像 (由 .gitignore 忽略)\n├── .gitignore                  # 指定 Git 忽略的文件和目录\n├── 423.pdf                     # (参考论文)\n├── CEGS_final_version.pdf      # (参考论文)\n├── README.md                   # (本项目的主要 README - 即本文档)\n└── test.py                     # 用于查看和可视化已处理数据的脚本\n```\n\n## 实现的 GNN 模型\n\n### 1. Baseline GraphSAGE\n\n标准的 GraphSAGE 模型，主要通过聚合邻居节点的特征来更新中心节点的表示。\n\n**核心思想:**\n对于每一层 \\(l\\)，每个节点 \\(v\\) 的表示 \\( \\mathbf{h}_v^{(l)} \\) 的计算分为两步：\n1.  **聚合 (Aggregate):** 从节点 \\(v\\) 的邻域 \\( \\mathcal{N}(v) \\) 收集信息：\n    \\[\n    \\mathbf{h}_{\mathcal{N}(v)}^{(l)} \\leftarrow \\text{AGGREGATE}_l \left( \left\\{ \\mathbf{h}_u^{(l-1)}, \\forall u \\in \\mathcal{N}(v) \\right\\} \\right)\n    \\]\n    其中 \\( \\text{AGGREGATE}_l \\) 可以是均值、最大值、求和或 LSTM 等聚合函数。\n2.  **更新 (Update):** 结合聚合后的邻域信息和节点自身上一层的信息来生成新的表示：\n    \\[\n    \\mathbf{h}_v^{(l)} \\leftarrow \\sigma \\left( \\mathbf{W}^{(l)} \\cdot \\text{CONCAT} \\left( \\mathbf{h}_v^{(l-1)}, \\mathbf{h}_{\mathcal{N}(v)}^{(l)} \\right) \\right)\n    \\]\n    其中 \\( \\mathbf{W}^{(l)} \\) 是可学习的权重矩阵，\\( \\sigma \\) 是非线性激活函数（如 ReLU）。\n\n### 2. R-GCN (Relational Graph Convolutional Network)\n\nR-GCN 专门设计用于处理图数据中不同类型的边（关系）。在本项目的上下文中，每个"边角色"被视为一种独立的关系。\n\n**核心思想:**\nR-GCN 为图中的每种关系类型 \\( r \\in \\mathcal{R} \\) 学习一个专属的可学习权重矩阵 \\( \\mathbf{W}_r^{(l)} \\)。节点 \\(v\\) 在第 \\( (l+1) \\) 层的表示 \\( \\mathbf{h}_v^{(l+1)} \\) 通过聚合来自不同关系类型连接的邻居节点 \\( u \\in \\mathcal{N}_r(v) \\) 的变换后信息，并结合自身信息的变换（通过 \\( \\mathbf{W}_0^{(l)} \\)）来计算：\n\\[\n\\mathbf{h}_v^{(l+1)} = \\sigma \\left( \\sum_{r \\in \\mathcal{R}} \\sum_{u \\in \\mathcal{N}_r(v)} \\frac{1}{c_{v,r}} \\mathbf{W}_r^{(l)} \\mathbf{h}_u^{(l)} + \\mathbf{W}_0^{(l)} \\mathbf{h}_v^{(l)} \\right)\n\\]\n其中：\n*   \\( \\mathcal{N}_r(v) \\) 是节点 \\(v\\) 在关系 \\(r\\) 下的邻居集合。\n*   \\( c_{v,r} \\) 是归一化常数，例如 \\( |\\mathcal{N}_r(v)| \\)。\n*   \\( \\mathbf{W}_0^{(l)} \\) 是用于变换节点自身信息的权重矩阵（自环）。\n*   \\( \\sigma \\) 是激活函数。\n\n**参数共享 (Basis Decomposition):**\n为了控制当关系类型数量很多时的模型复杂度，本项目实现了基分解 (Basis Decomposition) 参数共享机制：\n\\[\n\\mathbf{W}_r^{(l)} = \\sum_{k=1}^{B} a_{rk}^{(l)} \\mathbf{B}_k^{(l)}\n\\]\n模型学习 \\(B\\) 个基矩阵 \\( \\mathbf{B}_k^{(l)} \\) 和每个关系的特定系数 \\( a_{rk}^{(l)} \\)。`RGCNLayer` 类通过 `num_bases` 参数支持此功能。\n\n### 3. Edge-Conditional GraphSAGE\n\n此方法修改了标准 GraphSAGE 的消息计算阶段，使生成的消息显式地依赖于邻居节点及其连接边的角色特征。\n\n**核心思想:**\n1.  **消息计算 (Message Calculation):**\n    对于从邻居 \\( u \\) 到节点 \\( v \\) 的边 \\( e_{uv} \\)，其消息 \\( \\mathbf{m}_{uv}^{(l)} \\) 的计算结合了邻居节点 \\( u \\) 上一层的表示 \\( \\mathbf{h}_u^{(l-1)} \\) 和边 \\( e_{uv} \\) 的角色特征嵌入 \\( \\mathbf{x}_{uv} \\)：\n    \\[\n    \\mathbf{m}_{uv}^{(l)} = \\text{Activation} \\left( \\mathbf{W}_M^{(l)} \\cdot \\text{CONCAT} \\left( \\mathbf{h}_u^{(l-1)}, \\mathbf{x}_{uv} \\right) \\right)\n    \\]\n    其中 \\( \\mathbf{W}_M^{(l)} \\) 是一个可学习的权重矩阵。\n2.  **邻居聚合 (Neighbor Aggregation):**\n    与标准 GraphSAGE 类似，聚合所有邻居传来的边条件消息：\n    \\[\n    \\mathbf{h}_{\mathcal{N}(v)}^{(l)} \\leftarrow \\text{AGGREGATE}_l \left( \left\\{ \\mathbf{m}_{uv}^{(l)}, \\forall u \\in \\mathcal{N}(v) \\right\\} \\right)\n    \\]\n3.  **节点更新 (Node Update):**\n    最终的节点表示更新结合了聚合后的邻域信息和节点自身上一层的信息：\n    \\[\n    \\mathbf{h}_v^{(l)} \\leftarrow \\sigma \\left( \\mathbf{W}^{(l)} \\cdot \\text{CONCAT} \\left( \\mathbf{h}_v^{(l-1)}, \\mathbf{h}_{\mathcal{N}(v)}^{(l)} \\right) \\right)\n    \\]\n\n## 数据处理 (`cegs_gnn/data_utils/data_loader.py`)\n\n*   **`EdgeRoleEncoder`**:\n    *   负责将类别化的边角色标签转换为 GNN 模型所需的数值输入。\n    *   对于 R-GCN，它将角色标签映射为整数索引 (`edge_type`)。\n    *   对于 Edge-Conditional GraphSAGE，它将角色标签映射为可学习的嵌入向量 (`edge_attr`)，内部使用 `torch.nn.Embedding`。\n\n*   **`CEGSGraphDataset(InMemoryDataset)`**:\n    *   PyTorch Geometric 的数据集类，用于处理和加载图数据。\n    *   它在 `__init__` 中接收原始的 NetworkX 图列表、节点特征字典、边角色字典和节点标签字典。\n    *   通过 `process_for_rgcn` 和 `process_for_edge_sage` 参数控制在 `process()` 方法中是否为图生成 `edge_type` 或 `edge_attr`。\n    *   `process()` 方法将原始数据转换为 PyG 的 `Data` 对象列表，并处理节点特征 (`x`)、节点标签 (`y`) 以及根据需要生成的 `edge_type` 或 `edge_attr`。\n    *   处理后的数据被缓存到磁盘，以加速后续加载。缓存文件名根据处理类型和版本号（目前为 `_v3`）区分。\n\n*   **`load_cegs_like_synthetic_data()`**:\n    *   一个自定义的合成数据生成器，旨在创建比完全随机图更有意义的数据，模拟简化的代码结构。\n    *   **节点类型 (`NODE_TYPES`):** \'Start\', \'Assignment\', \'FunctionCall\', \'IfStatement\', \'Return\', \'End\'。\n    *   **节点特征:** 基于节点类型的独热编码（添加少量噪声）。\n    *   **边角色 (`EDGE_ROLES`):** \'next_statement\', \'calls\', \'condition_true\', \'condition_false\', \'returns_to\'。\n    *   **节点标签:** 根据节点类型分为三类 (0: Standard, 1: Control, 2: Action/Return)。\n    *   图结构通过编程方式生成，包含顺序流、`IfStatement` 引入的分支和简化的 `FunctionCall`/`Return` 结构。\n\n*   **`prepare_data_for_models()`**:\n    *   此函数协调数据加载。它可以选择加载旧的随机合成数据或新的 `cegs_like_synthetic_data`。\n    *   为 baseline, RGCN, 和 Edge-Conditional SAGE 创建三个独立的 `CEGSGraphDataset` 实例。每个实例配置为生成其对应模型所需的特定边属性（`edge_type` for RGCN, `edge_attr` for EdgeSAGE），并使用不同的根目录来管理各自的缓存。\n    *   返回三个数据集实例以及从数据中确定的关系数量、类别数量和特征维度。\n\n## 训练与评估\n\n*   **`cegs_gnn/training/trainer.py`**:\n    *   包含 `ModelTrainer` 类。\n    *   负责通用的模型训练循环 (`train_epoch`)、验证循环 (`validate`)、早停逻辑、模型保存和加载。\n    *   通过 `_get_forward_args` 方法，使用 Python 的 `inspect` 模块动态检查模型 `forward` 方法的签名，并仅传递模型实际接受的参数（`x`, `edge_index`, `edge_type`, `edge_attr`），从而适配不同模型的输入需求。\n    *   还提供 `predict` (进行预测) 和 `get_embeddings` (提取节点或图嵌入) 方法。\n\n*   **`cegs_gnn/evaluation/evaluator.py`**:\n    *   包含 `ModelEvaluator` 类。\n    *   用于执行评估任务。在当前版本中，主要关注节点分类任务。\n    *   `evaluate_example_recommendation` 方法（目前在主示例脚本中被部分注释）用于模拟图级别的推荐任务。\n    *   `visualize_training_history`: 使用 `matplotlib` 绘制训练和验证过程中的损失和指标曲线。\n    *   `visualize_node_embeddings`: 使用 t-SNE 降维并可视化节点嵌入。\n    *   所有绘图相关的中文标签和标题已被替换为英文。\n\n*   **`cegs_gnn/evaluation/metrics.py`**:\n    *   包含常用的评估指标函数，如准确率 (`accuracy`)、精确率、召回率、F1分数、Top-K 准确率、MRR 等。\n\n## 安装与运行\n\n### 1. 环境设置 (推荐使用 Conda)\n```bash\nconda create -n cegs python=3.9 -y\nconda activate cegs\n```\n\n### 2. 安装依赖\n首先确保 PyTorch 已安装。然后安装 PyTorch Geometric 及其依赖，最后安装其他包。\n\n```bash\n# 进入项目根目录\ncd /path/to/your/cegs/project\n\n# 激活环境 (如果未激活)\n# conda activate cegs\n\n# 安装 PyTorch (请根据你的系统和 CUDA 版本从 PyTorch官网 获取正确的命令)\n# 例如，对于 macOS (CPU):\npip install torch torchvision torchaudio\n\n# 安装 PyTorch Geometric 核心库\npip install torch-geometric\n\n# 安装 PyTorch Geometric 的可选扩展 (对于 CPU)\n# (注意：在某些系统上，这些包可能需要从源码编译，如果遇到问题，请参考 PyG 官方文档)\npip install torch-scatter torch-sparse torch-cluster -f https://data.pyg.org/whl/torch-$(python -c \"import torch; print(torch.__version__)\")+cpu.html\n\n# 安装其余依赖\npip install -r cegs_gnn/requirements.txt\n```\n**注意:** `requirements.txt` 中的 `numpy` 版本已固定为 `1.26.4` 以避免与旧版 PyTorch 的兼容性问题。\n\n### 3. 运行示例\n\n#### a. 运行主要的训练和评估脚本:\n此脚本使用新的 CEGS-like 合成数据进行训练和评估。\n```bash\n# 确保在项目根目录 (/Users/rach/code/cegs)\npython -m cegs_gnn.examples.train_and_evaluate\n```\n结果（包括训练历史图和节点嵌入图）会保存在 `./results/` 目录下。数据缓存会保存在 `./data/` 下的对应子目录。\n\n#### b. 运行简化的训练脚本 (可选):\n```bash\npython -m cegs_gnn.examples.simple_train\n```\n\n#### c. 运行模型实例化测试 (可选):\n```bash\n# 进入 cegs_gnn 目录\ncd cegs_gnn\npython test_models.py\ncd .. \n```\n\n### 4. 查看生成的数据\n可以使用 `test.py` 脚本加载并打印已处理的缓存数据集中的图信息，并进行可视化。\n```bash\n# 确保在项目根目录 (/Users/rach/code/cegs)\npython test.py\n```\n你需要编辑 `test.py` 中的 `root_dir` 变量来选择查看 `base`、`rgcn` 还是 `edgesage` 的数据。\n\n## 未来可能的改进\n\n*   **更复杂的 CEGS-like 数据生成:** 当前的 `load_cegs_like_synthetic_data` 只是一个初步的模拟。可以进一步增强它以生成更复杂、更接近真实代码片段的图结构，例如更深入的调用关系、循环、更复杂的条件分支等。\n*   **集成真实 CEGS 任务:** 当前的训练任务是基于节点类型的分类。为了真正评估模型在 CEGS 中的效果，需要将其集成到 Querier (示例推荐) 和 Classifier (节点映射) 的实际任务流程中，并使用相应的损失函数和评估指标。\n*   **超参数调优:** 对模型进行细致的超参数调优。\n*   **参数共享策略:** 为 R-GCN 实现并测试块对角分解 (Block-Diagonal Decomposition)。\n\n 